class Solution(object):
    def nthSuperUglyNumber(self, n, primes):
        """
        :type n: int
        :type primes: List[int]
        :rtype: int
        """
        # O(N * k * logk), 1520 ms
        h = set([1])
        hq = [1]
        for _ in range(n):
            small = heapq.heappop(hq)
            for p in primes:
                if small * p not in h:
                    # print(small, p, small * p)
                    heapq.heappush(hq, small * p)
                    h.add(small * p)
        return small


class Solution(object):
    def nthSuperUglyNumber(self, n, primes):
        """
        :type n: int
        :type primes: List[int]
        :rtype: int
        """
        # O(nlogk) 348ms
        # {num, prime, index}, num represents the value of the node, 
        # prime means which sorted list this node is in, 
        # and index tells us how far we have gone in that list
        cand = [(p, p, 1) for p in primes]
        ugly = [1]
        for _ in range(n-1):
            ugly.append(cand[0][0]) # append the smallest candidate in the heap
            while cand[0][0] == ugly[-1]:
                # there could be identical value generated by different p. 
                # e.g. 14 = 2 * 7 = 7 * 2. So I used a while loop 
                # to pop all identical ugly number in candidate list.
                x, p, i = heapq.heappop(cand)
                heapq.heappush(cand, (p * ugly[i], p, i + 1))
        return ugly[-1]