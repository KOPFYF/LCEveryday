class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        n = len(graph)
        dsu = DSU(n)
        for i in range(n):
            for j in range(i + 1, n):
                if graph[i][j]:
                    dsu.union(i, j)
        
        # Return the biggest union's malware if there is one and only one malware.
        # If no such union that has and has only one malware,
        # return the malware with minimum index.
        malware = Counter(dsu.parents[i] for i in initial)
        # print(malware) # Counter({1: 2})
        area = Counter(dsu.parents)
        # print(area) # Counter({1: 2, 2: 1})
        
        save, res = 0, min(initial)
        for i in initial:
            if malware[dsu.find(i)] == 1:
                if area[dsu.find(i)] > save:
                    save, res = area[dsu.find(i)], i
                elif area[dsu.find(i)] == save:
                    res = min(res, i)
        return res
        
        return min(initial, key=lambda x: [(malware[dsu.find(x)] == 1) * -area[dsu.find(x)], x])

          
class DSU(object):
    # Union by size
    def __init__(self, n):
        self.parents = [0] * n
        self.size = [1] * n
        for i in range(n):
            self.parents[i] = i
    
    def find(self, x):
        # Path compression
        if self.parents[x] != x: # if x is nott root
            self.parents[x] = self.find(self.parents[x]) # recursion
        return self.parents[x]
    
    def union(self, x, y):
        rootx, rooty = self.find(x), self.find(y)
        if rootx == rooty:
            return
        if self.size[rootx] <= self.size[rooty]:
            self.parents[rootx] = rooty
            self.size[rooty] += self.size[rootx]
        else:
            self.parents[rooty] = rootx
            self.size[rootx] += self.size[rooty]
            
    def isConnect(self, x, y):
        return self.find(x) == self.find(y)