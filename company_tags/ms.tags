--- July 2021
146. LRU do it again, one bug, (if self.size > self.capacity) should not be equal
	2 functions would be enough -- 1. remove() 2. appendleft()
200. not bug free, write BFS again, dfs bug free
277. TLE. Hint: step 1, find the candidate -> step 2, validate the candidate
54. done with hint, confirm range, l, r, u, d and do 4 loops periodically
1647. no clue greedy
706. design hashmap, not bug free with hint(self.next = None). do it again
1578. greedy, use prev index! I was trying to group using a list
722. string, do it again
460. LFU, no AC, debugging...
545. Boundary of Binary Tree. forgot, do it again
348. Design Tic-Tac-Toe, AC by checking the soln
253. Meeting Rooms II, sweep line O(n), done with hint. heap soln need to check if hq is empty when pop
708. Insert into a Sorted Circular Linked List. totally forget... 2 ptrs, 3 cases
1576. Replace All ?'s to Avoid Consecutive Repeating Characters. Brute force but take care of boundary with "or"
117. Populating Next Right Pointers in Each Node II. review!
588. Design In-Memory File System. Do it urself
1096. Brace Expansion II. Do it urself
54. Spiral Matrix. Bug free AC!
706. Design HashMap, still need hint...



--- Sep 24 2021, Microsoft Suzhou Applied Scientist ---
1448 AC
1822 AC
146  AC
200  AC
1647 greedy no clue again. keep a seen set to record freq. for dup freq, freq--, res++
    - while freq and freq in seen
277 AC
1405 heap + greedy, simulation
1615 AC
212 Hard
706  Design Hashmap. LinkedList, cache = [Node*1000], define cache function
    - AC
1578 Greedy, we need cost = sum_cost(group) - max_cost(group)
428 Hard
273 Hard
545 Boundary of Binary Tree, bottom should not include root. if node != root 
    - AC
588 Hard
722 3 cases, //, /*, */. use a buffer & block_open flag
443 fast and slow ptrs. i is the compressed/slower one. j is to find the group
253 AC. sweep line(heap is also O(nlgn)). sort after sweep. meeting room1 is O(n) by checking overlap
56  AC
340 Sliding win. need to redo it
54  Some bug with the index
151 AC
915 Have the prefix idea, but stuck with index issue. should compare left[i] <= right[i+1] for i in range(n-1)



